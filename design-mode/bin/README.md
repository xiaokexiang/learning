## 总结
## Spring pattern 总结

### GoF23中设计模式
|分类|设计模式|
|:---|:---|
|创建型|工厂方法模式、抽象工厂模式、原型模式、单例模式、建造者模式|
|结构型|适配器模式、桥接模式、代理模式、组合模式、装饰者模式、门面模式、享元模式|
|行为型|观察者模式、策略模式、备忘录模式、状态模式、访问者模式|

### Spring中常用设计模式
|设计模式|归纳|举例|
|:---|:---|:---|
|工厂模式|只对结果负责, 封装创建过程|BeanFactory、Calender|
|单例模式|保证独一无二|ApplicationContext、Calender|
|原型模式|一个猴毛, 吹出千万个猴子|ArrayList|
|代理模式|找人办事, 增强职责|JdkDynamicAopProxy、CglibAopProxy|
|委派模式|干活算你的, 功劳归我|DispatchServlet、BeanDefinitionParserDelegate|
|策略模式|用户选择, 结果统一|InstantiationStrategy|
|模板模式|流程标准化、自己实现定制|JdbcTemplate、HttpServlet|
|适配器模式|兼容转换头|AdvisorAdapter、HandlerAdapter|
|装饰者模式|包装、同宗同源|BufferReader、InputStream、OutputStream|
|观察者模式|在任务完成时通知|ContextLoaderListener|

---

## 单例模式

|模式|特点|
|:---|:---|
|饿汉式|线程安全，不管用不用都创建|
|懒汉式|线程不安全，懒加载|
|静态内部类|线程安全，不能够传参|
|双重确认|需要锁保证线程安全，影响性能|
|枚举类|上述4中都存在反射和序列化问题，枚举避免了这些问题|

---

## 适配器模式
`是指将一个类的接口转换成用户期望的一个接口, 使原本不兼容的类可以一起工作, 属于结构型设计模式`

### 适用场景

- 已经存在的类的方法和需求不匹配(方法结果相同或相似)的情况
- 随着软件的发展, 由于不用产品和不同厂家造成功能类似而接口不同的问题解决方案

### 概念
- 目标对象target: 最终需要完成的接口
- 适配者角色adaptee: 已有接口与target不符合
- 适配器角色adapter: 将adaptee改成target接口

### 源码
- AdvisorAdapter
- HandlerAdapter

---

## 装饰者设计模式
`是指在不改变原有对象的基础上, 将功能附加到对象上, 提供了比继承更有弹性的解决方法(扩展原有对象的功能), 属于结构型设计模式`

### 适用场景

- 扩展一个类的功能或给一个类添加附加功能
- 动态的给一个对象添加功能, 这些功能可以动态的撤销

### 比较
- 和静态代理相比, 装饰模式更注重扩展, 静态代理更注重功能加强, 使得职责变得不一样
- 装饰模式和适配器模式都是包装模式, 装饰者模式也是一种特殊的代理模式

| |装饰者模式|适配器模式|
|:---|:---|:---|
|形式|一种特别的适配器模式|没有层级关系, 装饰者模式又层级关系|
|定义|装饰者和被装饰者实现同一个接口, 主要目的是扩展后保持oop关系|适配器和被适配者没有必然关系, 通常采用继承或代理的形式进行包装|
|关系|满足is-a的关系|满足has-a的关系|
|功能|注重覆盖、扩展|注重兼容、转换|
|设计|前置考虑|后置考虑|

### 源码
- inputStream & outPutStream等

---

## 委派模式
`委派模式(Delegate pattern)的基本作用就是负责任务的调用和分配, 可以看作一种特殊情况下的静态全权代理。
代理模式注重过程, 而委派模式注重结果。同时委派模式不属于GOF23种设计模式`

---

## 工厂模式

### 简单工厂模式
`简单工厂模式是指由一个工厂对象决定创建哪一种产品类的实例, 所以它有一个缺点:
就是工厂类的职责相对过重, 不易于扩展相对复杂的产品结构。(简单工厂模式不属于23中设计模式)`

### 工厂方法模式
`工厂方法模式是指定义一个创建对象的接口, 但让实现这个接口的类来决定实例化哪个类。工厂方法模式让类的实例化推迟到子类中进行`

### 抽象工厂模式
`抽象工厂模式是指提供一个创建一系列相关或者相互依赖对象的接口, 无需指定他们的具体类`

---

## 观察者设计模式
- 观察者模式支持广播通信
- jdk自带的api, observable类似平台、observer类似观察者, 在setChanged()、notifyObservers()后回调observer的update()函数

---

## 原型设计模式
`原型设计模式是指原型实例指定创建对象的种类, 并且通过复制这些原型创建新的对象, 从而避免使用复杂的构造函数生成对象`

### 分类

#### 浅克隆
`被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用都仍然指向原来的对象`

#### 深克隆
`把引用对象的变量指向复制过的新对象,而不是原有的被引用的对象`

```java
public class deepClone {
  public void test() {
    try {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        ObjectOutputStream os = new ObjectOutputStream(outputStream);
        // 将this 写入到ByteArrayOutputStream
        os.writeObject(this);
    
        ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(inputStream);
        // 从ByteArrayInputStream读取
        QiTianDaSheng object = (QiTianDaSheng) ois.readObject();
        object.birthday = new Date();
        return object;
    } catch (Exception e) {
        throw new RuntimeException(e.getMessage());
    }
  }
}
```

### 应用场景

- 类初始化资源消耗过多
- 使用new 生成一个对象需要繁琐的过程
- 构造函数复杂
- 循环体中产生大量对象

---

## 代理
`是值为其他对象提供代理, 以控制对这个对象的访问, 代理对象在客户端和目标对象之间。
主要有两个目的, 一是保护目标对象、二是增强目标对象`

### 动态代理
`动态的生成代理类,以达到保护或增强目标对象的作用`

### jdk动态代理流程
- 获取被代理对象的引用, 并获取它所有的接口(反射获取)
- jdk动态代理类重新生成一个新类, 同时新类要实现被代理类的实现的所有接口
- 动态的生成代理类代码
- 将代理类的java代码编译生成.class文件
- 重新加载到JVM虚拟机中

### Cglib代理
`不需要实现任何接口, 通过动态的继承目标对象实现动态代理`

### JDK代理和Cglib代理的区别
- JDK动态代理实现了`被代理对象的接口`, Cglib代理`继承了被代理对象`
- 两者都在`运行期生成字节码`, JDK动态代理直接写Class字节码, 而Cglib动态代理使用`ASM`框架
写Class字节码, 所以`Cglib生成代理类的效率低于JDK动态代理`
- JDK动态代理调用代理方法是通过`反射调用`, Cglib代理是通过`FastClass机制`直接调用方法, Cglib调用方法效率更高

---

## 策略模式
`是指定义了算法家族并分别封装起来, 让他们之间可以互相替换, 此模式是的算法的变化不会影响使用此算法的客户`
`利用的是多态的思想, 将抽象类或接口作为入参, 父类的引用指向实现的子类。多重策略之间可以继承使用`
### 应用场景

- 系统中由很多类, 而他们的区别仅仅在于行为不同
- 一个系统需要动态的几种算法中选择一种

### 优缺点
- 符合开闭原则
- 避免使用ifelse语句
- 提高算法的保密性和安全性

- 客户端必须知道所有的策略并自行决定使用哪个策略
- 代码中存在过多的策略类, 增加了代码的维护难度

---

## 模板方法设计模式
`定义一个算法的骨架, 并允许子类为一个或者多个步骤提供实现。模板方法可以使得子类在不改变算法结构的情况下, 重新定义某些步骤, 属于行为型设计模式`

### 适用场景

- 一次性实现一个算法的不变部分, 并将可变的行为留给子类实现
- 各子类中的公共行为被提取出来并集中到一个公共的父类中, 从而避免代码重复

