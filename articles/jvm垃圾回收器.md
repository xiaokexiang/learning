### JVM中经典的垃圾回收器

下图是来自<a href="https://blogs.oracle.com/jonthecollector/our-collectors">oracle官方博客</a>中介绍垃圾回收器之间的关系图。

![](https://image.leejay.top/image/20200817/GDG377Ck8xwv.jpg?imageslim)

> 黄色代表`新生代`，灰色代表`老年代`，两个垃圾回收器之间相连表示`这两个垃圾回收器组合使用`。
>
> `Serial & CMS` 与 `ParNew & Serial Old`两组 在`JDK8`中已过期，`JDK9`中已移除。
>
> 我们用`并行`、`并发`来形容不同的收集器：
>
> 并行：描述的是多条垃圾回收器线程之间的关系，默认此时的`用户线程处于等待`状态。
>
> 并发：描述垃圾回收器线程与用户线程间的关系，说明同一时间`垃圾回收器线程与用户线程都在运行`。

---

### 新生代收集器

以下三种收集器都采用的是`标记-复制算法`来实现收集器的回收逻辑。

#### Serial收集器

使用`单线程`工作的收集器，除了只会用`一个处理器或一个收集线程`去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须`暂停其他所有的工作线程(STW)`，直到收集结束。是`客户端模式`下默认新生代收集器。

> 客户端/服务端区别：client比server模式`启动速度更快`，当server比client模式`运行速度更快`。

相比其他垃圾收集器，`Serial收集器`时所有垃圾回收器里面`额外内存消耗最小的`，但`STW耗时是最长的`；对于`单核处理器或处理器核心较少`环境来说，由于没有线程交互的开销，`Serial收集器`可以获得`最高的单线程收集效率`。

```bash
-XX:+UseSerialGC 新生代 & 老年代都使用串行收集器
```

#### ParNew收集器

`ParNew收集器`本质上是`Serial收集器`的`多线程并行`版本。除了`同时使用多条线程`进行垃圾收集外，其余的和`Serial收集器`一致。

> 这里的并行指的是：`同一个时间有多个`这样的收集线程在协调工作，用户线程此时处于等待状态。

除了`Serial收集器`外，只有`ParNew收集器`能与`CMS收集器`配合工作。

```bash
# 新生代ParNew & 老年代CMS 是开启CMS下新生代默认收集器
-XX:+UseConcMarkSweepGC
# 新生代ParNew & 老年代SerialOld（JDK8后已过期）
-XX:+UseParNewGC  
```

因为线程交互的开销，在`单核处理器`下性能低于`Serial`，但是`多核心`下`ParNew`收集器还是很高效的。

```bash
# 垃圾收集的线程数为8
-XX:ParallelGCThreads=8
```

> 不设置此参数时，当`Cpu Cores < 8`时，`Threads=Cpu Cores`，否则 `Threads=3+(5*cores)/8）`。

#### Parallel Scavenge收集器

相比`ParNew收集器`目标是`减少用户线程的停顿时间`，`Paraller收集器`关注则是`可控制的吞吐量`。
$$
吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 运行垃圾收集时间）
$$

> 假设JVM执行完成某个请求共需要100分钟，其中垃圾收集花费1分钟，那么吞吐量就是`99%`。
>
> `低停顿时间`适合`用户交互或保证服务响应`的程序。`高吞吐量`适合`最高效率`利用处理器资源，`尽快`完成程序的`运算任务`。
>
> `停顿时间`缩短是以牺牲`吞吐量和新生代空间`为代价的。如果我们将新生代设置的较小，虽然会减少每次回收的时间，但是会导致垃圾回收更加频繁，虽然停顿时间在减少，但是吞吐量在下降。

```bash
# 允许设置一个大于0的毫秒数，收集器尽量保证内存回收时间不超过该值
-XX:MaxGCPauseMillis
# 允许设置一个大于0小于100的整数n
# 系统将花费不超过 1/(1+n)的时间进行回收 假设n=99，那么不超过1%时间进行回收。
-XX:GCTimeRatio
# 自适应GC策略，自动调整新生代大小，老年代晋年龄等 区别于ParNew是Paraller独有
-XX:+UseAdaptiveSizePolicy
```

---

### 老年代收集器

#### Serial Old收集器

是`Serial`收集器的老年代版本，基于`标记-整理`的`单线程`收集器，用于`客户端`模式下的HotSpot虚拟机使用。

在`服务端`模式下，有两个用途：JDK5及之前版本中与`Parallel Scavenge`配合使用；作为`CMS`收集器发生失败时的备用收集器。

#### Parallel Old收集器

JDK6推出，是`Parallel Scavenge`收集器的老年代版本，支持`多线程并发`收集，基于`标记-整理`算法实现。

`Parallel Old`配合`Parallel Scavenge`的组合，用于`注重吞吐量和处理器资源较为稀缺的`情况。

```bash
# Parallel Scavenge + Parallel Old,JDK8默认组合
-XX:+UseParallelGC
```

#### CMS收集器

CMS(`Concurrent Mark Sweep`)收集器是一种以获取`最短回收停顿时间`为目标的收集器。基于`标记-清除`算法。

##### 收集流程

- 初始标记

此阶段仅`标记GC Roots能直接关联到的对象`。需要停顿用户线程(STW)。

- 并发标记(并发)

基于`初始标记`阶段标记的`从GC Roots可直接关联的对象开始`遍历整个对象图的过程。不需要停顿用户线程，与垃圾回收线程一起工作。

- 重新标记(并行)

该阶段是为了修正并发标记期间，因`用户程序继续运作而导致标记产生变动的那部分对象`的标记记录。

- 并发清除(并发)

清理删除掉标记阶段的已死亡对象，此阶段不需要移动存活对象。

##### CMS收集器缺点

- 对处理器资源敏感

因为CMS的并发阶段会`占用一部分线程`会导致应用程序变慢，降低吞吐量。默认回收线程数是`(Cpu Cores + 3 ) / 4`，若Cpu Cores越小，那么对程序运行的影响较大。

- 无法处理浮动垃圾

在CMS`并发标记和并发清理`阶段，用户线程还在继续执行，就会有`新的垃圾对象`不断产生，但这些对象出现在初始标记阶段后，只能在下次垃圾回收中再处理这部分垃圾。

因为`CMS收集器`并发标记和并发清理的特性，必须`预留一些空间`提供给用户线程使用，不能等老年代满再工作。

```bash
# 当老年代使用了68%后CMS开始工作
# JDK5默认68%，JDK6默认92%
-XX:CMSInitiatingOccupancyFraction=68
```

>如果预留的内存不够用户线程分配新对象，会启用`Serial Old`进行`Major GC`。会带来较长的停顿时间。

- 产生大量空间碎片

因为CMS基于`比较-清除`算法，易产生大量的空间碎片，在无法给大对象分配内存时导致一次`Full Gc`。

```bash
# 默认开启，当CMS进行Full GC时开启内存碎片合并整理的过程 JDK9废弃
-XX:+UseCMSCompactAtFullCollection
# CMS在执行若干次不整理空间的Full GC后，下一次进行随便整理 JDK9废弃
-XX:CMSFullGCBeforeCompaction
```

> Full GC：对整个Java堆进行回收，包含新生代和老年代
>
> Minor GC：对新生代进行回收。
>
> Major GC：对老年代进行回收。

#### G1收集器

#### 概念

`G1(Garbage First)收集器`开创了面向`局部收集的设计思路`和`基于Region的内存布局形式`。目的是为了实现支持`停顿时间模型`的收集器。基于`标记-整理`算法。

> 停顿时间模型：支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。

相比于其他收集器要么面向新生代，要么面向老年代，而G1面向堆内存任何部分来组成`回收集(Collection Set)`进行回收。衡量标准由属于哪个分代变为哪块内存垃圾最多，回收收益最大。

相比于之前的固定大小和数量的区域划分的收集器，G1将堆内存分为`多个大小相等的独立区域(Region，默认分成2048份)`，每个`Region`可以根据需要扮演`Eden、Survivor或老年代空间`。

`Region`中还存在一类特殊的`Humongous`区域，用于存储大对象，G1认为只要大小超过一个`Region`容量一般的对象即为大对象，对于超过`Region`大小的对象，将会被存放在N个连续的`Humongous`区域中。

```bash
# 设置Region的大小(单位： B)，在[1MB,32MB]必须为2的幂次方
# 设置Region的大小=2097152B=2MB，不设置默认是1MB
-XX:G1HeapRegionSize=2097152
```

G1仍然保留新生代、老年代的概念，当它们不再是固定的区域了，改为`一系列区域(不需要连续)的动态集合`。G1在后台维护一个`优先级列表`，每次根据用户通过`-XX:MaxGCPauseMillis`指定的停顿时长`(默认200ms)`，优先回收价值收益最大的`Region`，以达到最大的收集效率。

#### 收集流程

- 初始标记

和CMS类似，标记`GC Roots`直接关联的对象，此阶段会产生`STW`。

- 并发标记(并发)

基于`初始标记`，从`GC Roots`开始对堆中对象进行可达性分析，并`递归扫描整个对象图`，找出可回收对象，此过程可与用户程序并发执行。

- 最终标记(并行)

对用户线程做另一个短暂的暂停，通过`原始快照SATB`处理并发标记导致的并发可达性问题（上章分析过）。

- 筛选回收(并行)

负责更新`Region`的统计数据，并按照回收价值和成本进行排序，根据用户期望的`停顿时间`来指定回收计划。可见多个`Region`合并成`回收集(Collection Set)`，将回收的`Region`中的对象移到空的`Region`，再清理旧的`Region`，设计到对象的移动(体现`标记-整理`算法)，此阶段`用户线程暂停`，`多条收集器线程并行`完成。

#### G1vsCMS

- 优势
  - 指定最大停顿时间
  - 不会产生内存空间碎片
- 劣势
  - 并发执行带来的较高的内存占用和负载
  - 每个`Region`都持有一份`卡表`导致堆内存的消耗。

---

###  收集器参数总结

#### 收集器选择参数

| 参数                              | 新生代            | 老年代       |
| --------------------------------- | ----------------- | ------------ |
| -XX:+UseSerialGC                  | Serial            | Serial Old   |
| -XX:+UseParallelGC(JDK8默认)      | Parallel Scavenge | Parallel Old |
| -XX:+UseParNewGC(JDK8过期)        | ParNew            | Serial Old   |
| -XX:+UseConcMarkSweepGC(JDK9过期) | ParNew            | CMS          |
| -XX:UseG1GC                       | G1                | G1           |

#### 收集器相关参数

| 收集器            | 相关参数                                                     | 注释                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ParNew & Parallel | -XX:ParallelGCThreads                                        | 指定并行回收线程数；<br>`cores<8? cores:3+((5*cores))/8)`    |
| ParNew            | -XX:ParallelGCThreads<br>-XX:MaxGCPauseMillis=n<br>-XX:GCTimeRatio<br>-XX:+UseAdaptiveSizePolicy | 指定并行回收线程数<br>最大回收停顿时长<br>吞吐量大小；不花费超过`1/1+n`时间回收<br>自适应GC策略，自动eden,s区大小 |
|                   |                                                              |                                                              |

