### JVM中经典的垃圾回收器

下图是来自<a href="https://blogs.oracle.com/jonthecollector/our-collectors">oracle官方博客</a>中介绍垃圾回收器之间的关系图。

![](https://image.leejay.top/image/20200817/GDG377Ck8xwv.jpg?imageslim)

> 黄色代表`新生代`，灰色代表`老年代`，两个垃圾回收器之间相连表示`这两个垃圾回收器组合使用`。
>
> `Serial & CMS` 与 `ParNew & Serial Old`两组 在`JDK8`中已过期，`JDK9`中已移除。

---

### 新生代收集器

以下三种收集器都采用的是`标记-复制算法`来实现收集器的回收逻辑。

#### Serial收集器

使用`单线程`工作的收集器，除了只会用`一个处理器或一个收集线程`去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须`暂停其他所有的工作线程(STW)`，直到收集结束。是`客户端模式`下默认新生代收集器。

> 客户端/服务端区别：client比server模式`启动速度更快`，当server比client模式`运行速度更快`。

相比其他垃圾收集器，`Serial收集器`时所有垃圾回收器里面`额外内存消耗最小的`，但`STW耗时是最长的`；对于`单核处理器或处理器核心较少`环境来说，由于没有线程交互的开销，`Serial收集器`可以获得`最高的单线程收集效率`。

```bash
-XX:+UseSerialGC 新生代 & 老年代都使用串行收集器
```

#### ParNew收集器

`ParNew收集器`本质上是`Serial收集器`的`多线程并行`版本。除了`同时使用多条线程`进行垃圾收集外，其余的和`Serial收集器`一致。

> 这里的并行指的是：`同一个时间有多个`这样的收集线程在协调工作，用户线程此时处于等待状态。

除了`Serial收集器`外，只有`ParNew收集器`能与`CMS收集器`配合工作。

```bash
# 是开启CMS下新生代默认收集器
-XX:+UseComcMarkSweepGC
# 新生代ParNew & 老年代SerialOld（JDK8后已过期）
-XX:+UseParNewGC  
```

因为线程交互的开销，在`单核处理器`下性能低于`Serial`，但是`多核心`下`ParNew`收集器还是很高效的。

```bash
# 垃圾收集的线程数为8
-XX:ParallelGCThreads=8
```

#### Parallel Scavenge收集器

相比`ParNew收集器`目标是`减少用户线程的停顿时间`，`Paraller收集器`关注则是`可控制的吞吐量`。
$$
吞吐量 = 运行用户代码时间 / (运行用于代码时间 + 运行垃圾收集时间）
$$

> 假设JVM执行完成某个请求共需要100分钟，其中垃圾收集花费1分钟，那么吞吐量就是`99%`。
>
> `低停顿`适合`用户交互或保证服务响应`的程序。
>
> `高吞吐`适合`最高效率`利用处理器资源，`尽快`完成程序的`运算任务`。



