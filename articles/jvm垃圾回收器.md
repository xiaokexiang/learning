### JVM中经典的垃圾回收器

下图是来自<a href="https://blogs.oracle.com/jonthecollector/our-collectors">oracle官方博客</a>中介绍垃圾回收器之间的关系图。

![](https://image.leejay.top/image/20200817/GDG377Ck8xwv.jpg?imageslim)

> 黄色代表`新生代`，灰色代表`老年代`，两个垃圾回收器之间相连表示`这两个垃圾回收器组合使用`。
>
> `Serial & CMS` 与 `ParNew & Serial Old`两组 在`JDK8`中已过期，`JDK9`中已移除。
>
> 我们用`并行`、`并发`来形容不同的收集器：
>
> 并行：描述的是多条垃圾回收器线程之间的关系，默认此时的`用户线程处于等待`状态。
>
> 并发：描述垃圾回收器线程与用户线程间的关系，说明同一时间`垃圾回收器线程与用户线程都在运行`。

---

### 新生代收集器

以下三种收集器都采用的是`标记-复制算法`来实现收集器的回收逻辑。

#### Serial收集器

使用`单线程`工作的收集器，除了只会用`一个处理器或一个收集线程`去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须`暂停其他所有的工作线程(STW)`，直到收集结束。是`客户端模式`下默认新生代收集器。

> 客户端/服务端区别：client比server模式`启动速度更快`，当server比client模式`运行速度更快`。

相比其他垃圾收集器，`Serial收集器`时所有垃圾回收器里面`额外内存消耗最小的`，但`STW耗时是最长的`；对于`单核处理器或处理器核心较少`环境来说，由于没有线程交互的开销，`Serial收集器`可以获得`最高的单线程收集效率`。

```bash
-XX:+UseSerialGC 新生代 & 老年代都使用串行收集器
```

#### ParNew收集器

`ParNew收集器`本质上是`Serial收集器`的`多线程并行`版本。除了`同时使用多条线程`进行垃圾收集外，其余的和`Serial收集器`一致。

> 这里的并行指的是：`同一个时间有多个`这样的收集线程在协调工作，用户线程此时处于等待状态。

除了`Serial收集器`外，只有`ParNew收集器`能与`CMS收集器`配合工作。

```bash
# 新生代ParNew & 老年代CMS 是开启CMS下新生代默认收集器
-XX:+UseConcMarkSweepGC
# 新生代ParNew & 老年代SerialOld（JDK8后已过期）
-XX:+UseParNewGC  
```

因为线程交互的开销，在`单核处理器`下性能低于`Serial`，但是`多核心`下`ParNew`收集器还是很高效的。

```bash
# 垃圾收集的线程数为8
-XX:ParallelGCThreads=8
```

> 不设置此参数时，当`Cpu Cores < 8`时，`Threads=Cpu Cores`，否则 `Threads=3+(5*cores)/8）`。

#### Parallel Scavenge收集器

相比`ParNew收集器`目标是`减少用户线程的停顿时间`，`Paraller收集器`关注则是`可控制的吞吐量`。
$$
吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 运行垃圾收集时间）
$$

> 假设JVM执行完成某个请求共需要100分钟，其中垃圾收集花费1分钟，那么吞吐量就是`99%`。
>
> `低停顿时间`适合`用户交互或保证服务响应`的程序。`高吞吐量`适合`最高效率`利用处理器资源，`尽快`完成程序的`运算任务`。
>
> `停顿时间`缩短是以牺牲`吞吐量和新生代空间`为代价的。如果我们将新生代设置的较小，虽然会减少每次回收的时间，但是会导致垃圾回收更加频繁，虽然停顿时间在减少，但是吞吐量在下降。

```bash
# 允许设置一个大于0的毫秒数，收集器尽量保证内存回收时间不超过该值
-XX:MaxGCPauseMillis
# 允许设置一个大于0小于100的整数n
# 系统将花费不超过 1/(1+n)的时间进行回收 假设n=99，那么不超过1%时间进行回收。
-XX:GCTimeRatio
# 自适应GC策略，自动调整新生代大小，老年代晋年龄等 区别于ParNew是Paraller独有
-XX:+UseAdaptiveSizePolicy
```

---

### 老年代收集器

#### Serial Old收集器

是`Serial`收集器的老年代版本，基于`标记-整理`的`单线程`收集器，用于`客户端`模式下的HotSpot虚拟机使用。

在`服务端`模式下，有两个用途：JDK5及之前版本中与`Parallel Scavenge`配合使用；作为`CMS`收集器发生失败时的备用收集器。

#### Parallel Old收集器

JDK6推出，是`Parallel Scavenge`收集器的老年代版本，支持`多线程并发`收集，基于`标记-整理`算法实现。

`Parallel Old`配合`Parallel Scavenge`的组合，用于`注重吞吐量和处理器资源较为稀缺的`情况。

```bash
# Parallel Scavenge + Parallel Old,JDK8默认组合
-XX:+UseParallelGC
```

#### CMS收集器

CMS(`Concurrent Mark Sweep`)收集器是一种以获取`最短回收停顿时间`为目标的收集器。基于`标记-清除`算法。

##### 收集流程

- 初始标记

此阶段仅`标记GC Roots能直接关联到的对象`。需要停顿用户线程(STW)。

- 并发标记(并发)

基于`初始标记`阶段标记的`从GC Roots可直接关联的对象开始`遍历整个对象图的过程。不需要停顿用户线程，与垃圾回收线程一起工作。

- 重新标记(并行)

该阶段是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那部分对象的标记记录。CMS是使用`增量更新`来解决并发标记产生的问题。

- 并发清除(并发)

清理删除掉标记阶段的已死亡对象，此阶段不需要移动存活对象。

##### CMS收集器缺点

- 对处理器资源敏感

因为CMS的并发阶段会`占用一部分线程`会导致应用程序变慢，降低吞吐量。默认回收线程数是`(Cpu Cores + 3 ) / 4`，若Cpu Cores越小，那么对程序运行的影响较大。

- 无法处理浮动垃圾

在CMS`并发标记和并发清理`阶段，用户线程还在继续执行，就会有`新的垃圾对象`不断产生，但这些对象出现在初始标记阶段后，只能在下次垃圾回收中再处理这部分垃圾。

因为`CMS收集器`并发标记和并发清理的特性，必须`预留一些空间`提供给用户线程使用，不能等老年代满再工作。

```bash
# 当老年代使用了68%后CMS开始工作
# JDK5默认68%，JDK6默认92%
-XX:CMSInitiatingOccupancyFraction=68
```

>如果预留的内存不够用户线程分配新对象，会启用`Serial Old`进行`Major GC`。会带来较长的停顿时间。

- 产生大量空间碎片

因为CMS基于`比较-清除`算法，易产生大量的空间碎片，在无法给大对象分配内存时导致一次`Full Gc`。

```bash
# 默认开启，当CMS进行Full GC时开启内存碎片合并整理的过程 JDK9废弃
-XX:+UseCMSCompactAtFullCollection
# CMS在执行若干次不整理空间的Full GC后，下一次进行碎片整理 JDK9废弃
-XX:CMSFullGCBeforeCompaction
```

> Full GC：对整个Java堆进行回收，包含新生代和老年代
>
> Minor GC：对新生代进行回收。
>
> Major GC：对老年代进行回收。

#### G1收集器

#### 概念

`G1(Garbage First)收集器`开创了面向`局部收集的设计思路`和`基于Region的内存布局形式`。目的是为了实现支持`停顿时间模型`的收集器。基于`标记-整理`算法。

> 停顿时间模型：支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。

相比于其他收集器要么面向新生代，要么面向老年代，而G1面向堆内存任何部分来组成`回收集(Collection Set)`进行回收。衡量标准由属于哪个分代变为哪块内存垃圾最多，回收收益最大。

相比于之前的固定大小和数量的区域划分的收集器，G1将堆内存分为`多个大小相等的独立区域(Region，默认分成2048份)`，每个`Region`可以根据需要扮演`Eden、Survivor或老年代空间`。

`Region`中还存在一类特殊的`Humongous`区域，用于存储大对象，G1认为只要大小超过一个`Region`容量一半的对象即为大对象，对于超过`Region`大小的对象，将会被存放在N个连续的`Humongous`区域中。

```bash
# 设置Region的大小(单位： B)，在[1MB,32MB]必须为2的幂次方
# 设置Region的大小=2097152B=2MB，不设置默认是1MB
-XX:G1HeapRegionSize=2097152
```

G1仍然保留新生代、老年代的概念，当它们不再是固定的区域了，改为`一系列区域(不需要连续)的动态集合`。G1在后台维护一个`优先级列表`，每次根据用户通过`-XX:MaxGCPauseMillis`指定的停顿时长`(默认200ms)`，优先回收价值收益最大的`Region`，以达到最大的收集效率。

#### 收集流程

- 初始标记

和CMS类似，标记`GC Roots`直接关联的对象，此阶段会产生`STW`。

- 并发标记(并发)

基于`初始标记`，从`GC Roots`开始对堆中对象进行可达性分析，并`递归扫描整个对象图`，找出可回收对象，此过程可与用户程序并发执行。

- 最终标记(并行)

对用户线程做另一个短暂的暂停，通过`原始快照SATB`处理并发标记导致的并发可达性问题（上章分析过）。

- 筛选回收(并行)

负责更新`Region`的统计数据，并按照回收价值和成本进行排序，根据用户期望的`停顿时间`来指定回收计划。可见多个`Region`合并成`回收集(Collection Set)`，将回收的`Region`中的对象移到空的`Region`，再清理旧的`Region`，设计到对象的移动(体现`标记-整理`算法)，此阶段`用户线程暂停`，`多条收集器线程并行`完成。

#### G1vsCMS

- 优势
  - 指定最大停顿时间
  - 不会产生内存空间碎片
- 劣势
  - 并发执行带来的较高的内存占用和负载
  - 每个`Region`都持有一份`卡表`导致堆内存的消耗。

---

### 对象在堆中的分配

前面我们了解到，`大部分`的对象都是在`堆中`进行内存分配，但堆中又存在多个逻辑区域(新生代、老年代)，所以这章我们就要讨论下，对象在堆中的进行内存分配的基本原则。

#### TLAB

在讨论对象分配前，我们需要对之前引入的`TLAB`的概念进一步解析。`TLAB(本地线程缓冲)`，其存在的目的是为了加速对象的分配，即每个线程都拥有自己的专属区域进行对象分配，来避免多线程冲突，默认是启动的。

```bash
# 开/关TLAB
-XX:+/-UseTLAB
# 设置TLAB大小
-XX:TLABSize
# 查看TLAB信息
-XX:+PrintTLAB
# 对象占TLAB空间的比例，大于此比例堆中分配，小于就废弃当前
## TLAB区域，并新建一个TLAB存放，默认64
-XX:TLABRefillWasteFraction=64
# 默认情况TLAB和refill_waste是动态的，关闭TLAB动态调整
-XX:-ResizeTLAB
```

> 我们假设TLAB大小为100KB，第一次分配给对象80KB，此时还剩20KB，如果第二次有30KB大小的对象需要分配，此时有两种选择：
>
> 1. 废弃所剩的20KB区域，新建一个TLAB存放30KB的对象。
> 2. 将30KB对象分配在堆上，保留所剩的20KB区域，等到下次有小于20KB对象分配时再使用该区域。
>
> `-XX:TLABRefillWasteFraction=64`，即允许TLAB空间浪费的比例，当`对象/TLAB的比例`大于64，对象在堆中分配，小于64则会开辟新TLAB存放。

#### 一般在eden中分配

大部分情况下，`对象在Eden区中进行分配`，如果`Eden区`空间不够，JVM会发起一次`Minor GC`。

#### 大对象进入老年代

`大对象：需要大量连续内存空间的Java对象`或新生代已无足够空间分配的对象直接进入老年代。

```bash
# 将大于此大小的对象直接分配到老年代
-XX:PretenureSizeThreshold=5242880(5mb)
```

> 只适用于`Serial、Serial Old、ParNew`三种收集器。

#### 长期存活对象进入老年代

长期存活的对象将进入老年代。对象通常在eden区诞生，如果经历了一次`Minor Gc`后仍然存活，并能够被`s0`容纳，该对象会被移动到`s0`区并将其`对象头中的对象年龄 + 1`。当年龄达到阈值，就会进入老年代。

```bash
# 对象晋升到老年代的年龄阈值
-XX:MaxTenuringThreshold=15
```

> `动态对象年龄判断`：
>
> JVM不是永远要求对象年龄达到`-XX:MaxTenuringThreshold`指定的值才能晋升老年代：
>
> 如果`s0中相同年龄的对象大小总`和大于s0区域的一半`(-XX:TargetSurvivorRatio决定，默认50)`，那么`大于等于该年龄的对象`就会进入老年代。

#### 总结

对象的内存分配流程需要经历`栈上分配 -> TLAB分配 -> 是否进入老年代 -> 最终eden分配`。