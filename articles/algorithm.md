### 数组
优点：高效的随机访问能力，给出index就能找到元素，时间复杂度：O(1)。
缺点：因为数组的容量一旦初始化就不能改变，所以在`添加或删除`操作时会因为容量不够导致数组扩容，时间复杂度：`O(n)`。
使用环境：`读操作多，写操作少的情况`，二分查找，就基于`有序数组`实现，时间复杂度：O(logn)。

### 链表
优点：元素之间不要求在内存中地址联系，所以在增加和删除不需要扩容，只需要修改指针，更加灵活，
     不考虑查询操作，增加和删除操作时间复杂度：`O(1)`。
缺点：随机访问能力不如数组，如果想获取指定index的元素，需要一层一层查找，时间复杂度O(n)。
使用环境：`适合大量需要往队尾/队首插入元素或删除元素的场景`。

| 线性结构 | 查询 | 插入 | 删除 |
| -------- | ---- | ---- | ---- |
| 数组     | O(1) | O(n) | O(n) |
| 链表     | O(n) | O(1) | O(1) |

> 特别指出：链表的插入和删除前提是`已经知道要操作元素的位置`，时间复杂度才是`O(1)`（例如队首和队尾）。

### 栈
栈是在`数组或链表(物理结构)`基础上实现的`逻辑结构(数据存储方式之类没有改变，但是处理逻辑改变了)`。
符合`FILO(First In Last Out)先进后出`规则。最早进入的元素存放的位置叫`栈底`，最新进入的元素存放的位置叫`栈顶`。

### 队列
队列也是在`数组或链表`基础上实现的`逻辑结构`。
符合`FIFO(First In First Out)先进先出`规则。队列的出口端叫做队首，队列的进口端叫做队尾。
> 因为队列的特性，队列不断的出队，导致队首左边的内存空间不再使用，可用空间越来越少。
> 基于这个问题，我们使用`数组`实现的循环队列可以解决(用链表会导致链表闭环)。


|       | 线性结构 | 非线性结构 |
| ----- | ------- | ------- |
| 逻辑结构     | 栈、队列 | 树、图 |
|  | 顺序存储结构 | 链式存储结构 | 
| 物理结构     | 数组 | 链表 |

### 散列表
又称作hash表，该数据结构提供了键值之间的映射关系。时间复杂度接近O(1); 常见的hash方法: `开发定址法和链表法`。

### 树
树是`n(n>=0)`个节点的有限集，当`n = 0`时，称为`空树`。
在任意一个非空树中，具有如下特点：
1. 有且仅有一个特定的的称为根的节点。
2. 当`n > 1`时，其余节点可以分为`m(m > 0)`个互不相交的有限集，每个集合本身又是一个树，并称为`根的子树`。

![](https://image.leejay.top/image/20200721/aaYt0un92eTI.png?imageslim)
> 图中: 节点1为根节点，6、7、8、9为叶子节点(树的末端，没有孩子节点的节点)。
> 以节点5为例：3是它的`父节点`，4是他的`兄弟节点`，8、9是它的`子节点`。图中树的深度为`4`。

#### 二叉树
`二叉树`是树的特殊形式，这种树的每个节点`最多有两个`孩子节点。分别为`左孩子和右孩子节点`。二叉树具有两种特殊形式：`满二叉树和完全二叉树`。可以用`数组或链表`实现。

##### 特殊的二叉树
- 满二叉树
  一个二叉树上所有的非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上。
- 完全二叉树
  与满二叉树类似，但是不要求非叶子节点都存在左右孩子，但所有的叶子节点必须在同一层。
![](https://image.leejay.top/image/20200721/YA6hqzTc7vE2.png?imageslim)

- 二分查找树(Binary Search Tree)
二叉查找树基于二叉树又增加了几个条件：
 1. 如果左子树不为空，则左子树上所有节点的值小于根节点的值。
 2. 如果右子树不为空，则右子树上所有节点的值大于根节点的值。
 3. 左、右子树也都是二分查找树。
二叉查找树的时间复杂度最优的情况下:`O(logn)`，最差的情况:`O(n)`。

#### 二叉树的遍历
- 前序
- 中序
- 后序
- 层序