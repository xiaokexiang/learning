### 数组
优点：高效的随机访问能力，给出index就能找到元素，时间复杂度：O(1)。
缺点：因为数组的容量一旦初始化就不能改变，所以在`添加或删除`操作时会因为容量不够导致数组扩容，时间复杂度：`O(n)`。
使用环境：`读操作多，写操作少的情况`，二分查找，就基于`有序数组`实现，时间复杂度：O(logn)。

### 链表
优点：元素之间不要求在内存中地址联系，所以在增加和删除不需要扩容，只需要修改指针，更加灵活，
     不考虑查询操作，增加和删除操作时间复杂度：`O(1)`。
缺点：随机访问能力不如数组，如果想获取指定index的元素，需要一层一层查找，时间复杂度O(n)。
使用环境：`适合大量需要往队尾/队首插入元素或删除元素的场景`。

| 线性结构 | 查询 | 插入 | 删除 |
| -------- | ---- | ---- | ---- |
| 数组     | O(1) | O(n) | O(n) |
| 链表     | O(n) | O(1) | O(1) |

> 特别指出：链表的插入和删除前提是`已经知道要操作元素的位置`，时间复杂度才是`O(1)`（例如队首和队尾）。

### 栈
栈是在`数组或链表(物理结构)`基础上实现的`逻辑结构(数据存储方式之类没有改变，但是处理逻辑改变了)`。
符合`FILO(First In Last Out)先进后出`规则。最早进入的元素存放的位置叫`栈底`，最新进入的元素存放的位置叫`栈顶`。

### 队列
队列也是在`数组或链表`基础上实现的`逻辑结构`。
符合`FIFO(First In First Out)先进先出`规则。队列的出口端叫做队首，队列的进口端叫做队尾。
> 因为队列的特性，队列不断的出队，导致队首左边的内存空间不再使用，可用空间越来越少。
> 基于这个问题，我们使用`数组`实现的循环队列可以解决(用链表会导致链表闭环)。


|       | 线性结构 | 非线性结构 |
| ----- | ------- | ------- |
| 逻辑结构     | 栈、队列 | 树、图 |
|  | 顺序存储结构 | 链式存储结构 |
| 物理结构     | 数组 | 链表 |

### 散列表
又称作hash表，该数据结构提供了键值之间的映射关系。时间复杂度接近O(1); 常见的hash方法: `开发定址法和链表法`。

### 树
树是`n(n>=0)`个节点的有限集，当`n = 0`时，称为`空树`。
在任意一个非空树中，具有如下特点：
1. 有且仅有一个特定的的称为根的节点。
2. 当`n > 1`时，其余节点可以分为`m(m > 0)`个互不相交的有限集，每个集合本身又是一个树，并称为`根的子树`。

![](https://image.leejay.top/image/20200721/aaYt0un92eTI.png?imageslim)
> 图中: 节点1为根节点，6、7、8、9为叶子节点(树的末端，没有孩子节点的节点)。
> 以节点5为例：3是它的`父节点`，4是他的`兄弟节点`，8、9是它的`子节点`。树深度为`4`。

#### 二叉树
`二叉树`是树的特殊形式，这种树的每个节点`最多有两个`孩子节点。分别为`左孩子和右孩子节点`。二叉树具有两种特殊形式：`满二叉树和完全二叉树`。可以用`数组或链表`实现。

##### 特殊的二叉树
- 满二叉树
  一个二叉树上所有的非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上。
- 完全二叉树
  与满二叉树类似，但是不要求非叶子节点都存在左右孩子，但所有的叶子节点必须在同一层。
![](https://image.leejay.top/image/20200721/YA6hqzTc7vE2.png?imageslim)

- `二分查找树(Binary Search Tree)`
  二叉查找树基于二叉树又增加了几个条件：
  
     1. 如果左子树不为空，则左子树上所有节点的值小于根节点的值。
     2. 如果右子树不为空，则右子树上所有节点的值大于根节点的值。
     3. 左、右子树也都是二分查找树。
  > 二叉查找树的时间复杂度最优的情况下:`O(logn)`，最差的情况:`O(n)`。

- 红黑树

  每个节点都是`红色/黑色`的`二叉查找树`。还添加了如下条件：

  1. 节点是红色或黑色，根节点是黑色。
  2. 每个叶子节点都是黑色的。
  3. 每个红色节点的两个子节点都是黑色的。
  4. 从任意一个节点到其每个叶子节点的所有路径都`包含相同数目`的`黑色`节点。

  在插入、删除时导致节点变化，通过`变色、左旋和右旋`来保持平衡。

  > 红黑树是一种特化的AVL树（`在相同节点情况下，红黑树的高度高于AVL树`），红黑树搜索、插入和删除的时间复杂度都为`O(logn)`。在这些操作较多的情况下推荐红黑树。

- 平衡二叉树(`Balance Tree`)

  AVL树的左右两个子树的`高度差绝对值不超过1`，并且左右两个子树也是一颗AVL树。包括：`B-Tree、B-Tree+`等。

  > 因为AVL树高度平衡的要求，频繁的插入修改都会导致重平衡。红黑树`插入最多旋转两次，删除最多旋转三次`。

#### 二叉树的遍历

| 遍历顺序 | 前序(深度)     | 中序(深度)     | 后序**(深度)** | 层序(广度)       |
| -------- | -------------- | -------------- | -------------- | ---------------- |
| 遍历规则 | 根、左子、右子 | 左子、根、右子 | 左子、右子、根 | 一层一层横向遍历 |

> 遍历顺序是由根节点何时输出来决定的，二叉树遍历分为：`深度优先和广度优先遍历`。

### 二叉堆
二叉堆分为：`最大堆和最小堆`，其本质上是一颗`完全二叉树`。他们的根节点叫做：`堆顶`。

>  最大堆：最大堆的任何一个父节点的值，`都大于或等于`它左、右节点的值。
>
> 最小堆：最小堆的任何一个父节点的值，`都小于或等于`它左、右节点的值。
>
> Java中`PriorityBlockingQueue和DelayQueue`是基于最小二叉堆实现。

二叉堆本质是完全二叉树，但因为需要顺序存储，所以底层物理结构是`数组`。那没有左右指针的情况下，如何表示左右节点呢？需要通过`数组下标`实现，基于`广度优先`遍历，如果某个节点`index = n`，那么它的左节点就是`2n + 1`，右节点就是`2n + 2`。

> 二叉堆的插入和删除时间复杂度：`O(logn)`，构建的时间复杂度：`O(n)`。

#### 优先队列

分为`最大优先队列和最小优先队列`。

> 最大优先队列：无论入队顺序如何，当前最大元素都会优先出队。
>
> 最小优先队列：无论入队顺序如何，当前最小元素都会优先出队。
>
> 无论是最大还是最小队列，其底层本质就是通过`最大或最小二叉堆`实现的。

### 排序

| 时间复杂度 | 排序算法                               |
| ---------- | -------------------------------------- |
| O(n^2)     | 冒泡排序、选择排序、插入排序、希尔排序 |
| O(nlogn)   | 快速排序、归并排序、堆排序             |
| O(n)       | 计数排序、桶排序、基数排序             |

