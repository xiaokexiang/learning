## 数据库事务及特性

> 事务（Transcation）：访问并可能更新数据库中各数据项的一个程序执行单元。当在`数据库修改数据成功时，在事务中修改的数据便会提交，不再改变。否则事务就取消或回滚，更改无效。`

### 事务特性

#### 原子性（Atomicity）

即事务包含的所有操作要么全部成功，要么全部失败。

#### 一致性（Consistency）

即一个事务执行前后都必须处于一致性状态。比如A和B一共有2000元，他两无论如何转账相加必须还是2000。

#### 隔离性（Isolation）

即当多个用户并发访问数据库时，为每个用户开启的事务都不能互相干扰，事务间需要相互隔离。

#### 持久性（Durability）

即事务一旦被提交，那么对数据库中数据改变是永久性，即使数据库故障也不会丢失提交事务的操作。

> 以`MySql的InnoDB引擎`为例，ACID通过`InnoDB日志和锁`实现：
>
> 原子性 & 一致性：通过`Undo log`，在操作任何数据之前，将数据备份到一个地方（即`Undo log`），如果之后出现错误或者事务回滚，系统会基于`Undo log`将数据恢复到事务开始之前状态。
>
> 隔离性：通过数据库的`锁和MVCC多版本控制`来实现。
>
> 持久性：通过`redo log`实现，其记录的是像数据的备份。在事务提交前只将`redo log`持久化，这样即使系统崩溃，数据没有持久化，但是系统可以根据`redo log`将数据恢复到最新状态。

---

### 隔离性及隔离级别

#### 隔离问题

如果我们使用数据库时不考虑隔离级别，那么会导致如下三个问题：

- 脏读

  即`一个事务读取了另一个未提交事务中的数据。`

  比如事务A正在多次修改数据，事务B读取了事务A正在修改的数据，结果事务A回滚，即会导致数据不一致。

- 不可重复读

  `针对数据库某条数据，一个事务范围内多次查询却返回不同的数据值。`

  比如在事务A内，第一次读取了数据X，但事务A还未结束，此时事务B也访问了数据X并修改及提交，之后事务A又再次读取了X，导致两次读取数据不一致。

- 幻读

  `针对符合条件的部分数据，一个事务范围内多次查询却返回不同数量的数据。`

  比如在事务A内，读了部分数据，但事务A还未结束，此时事务B插入了新的记录（该记录符合查询条件），之后事务A再次查询，导致两次读取数据数量不一致。

  > 不可重复度和幻读很相似，其实`不可重复读的重点在于update和delete`，某条数据前后不一致，侧重点在于数据，通过`锁行`实现避免。而`幻读重点在于insert`，前后返回的数据量不一致，侧重点在于数量，通过`锁表`实现避免。

#### 隔离级别

针对上面的三个问题，SQL规范定义了4个事务隔离级别：

- Read Uncommitted（读未提交）c

  最低级别，无法解决以上三个问题。

- Read Committed（读已提交）

  `能够避免脏读`，不能避免不可重复读和幻读。`Oracle的默认隔离级别。`

- Repeatable Read（可重复读）

  `能够避免脏读和不可重复读`，不能避免幻读。`MySql默认隔离级别。`

- Serializable （串行化）

  三个问题都能避免。

| 事务隔离级别     | 脏读 | 不可重复读 | 幻读 |
| :--------------- | :--- | :--------- | :--- |
| Read Uncommitted | 是   | 是         | 是   |
| Read Committed   | 否   | 是         | 是   |
| Repeatable Read  | 否   | 否         | 是   |
| Serializable     | 否   | 否         | 否   |

> 事务隔离级别的实现方式基本分为两种：
>
> 1. 在读取数据之前，对其加锁，阻止其他事务对数据进行修改。
> 2. 通过机制生成一个`数据请求时间点的一致性数据快照`，保证在`同一个事务中前后数据一致性`。这种技术又称为`MVCC(多版本控制)`，只在`Read Committed 和 Repeatable Read`下工作。
> 3. `Read Committed`的事务中，每一条select都有自己的一致性`Read View`，而在`Repeatable Read`中，事务中的一致性`Read View`是以第一条select语句为时间点，只能读取此时间点以前已提交数据。

![](https://image.leejay.top/image/20200702/wVs5JubWtlmF.png?imageslim)

> 根据如上执行流程，r1和r2的返回值会是多少？

| 事务B隔离级别    | r1   | r2   |
| :--------------- | :--- | :--- |
| Read Uncommitted | 20   | 20   |
| Read Committed   | 10   | 20   |
| Repeatable Read  | 10   | 10   |
| Serializable     | 10   | 10   |

#### MySql隔离级别的选择

我们知道MySql默认事务隔离级别是`Repeatable Read`，但是我们也推荐使用`Read Committed`。

在解释为什么之前，我们需要知道什么是`间隙锁:我们使用范围条件查询数据，对于在此范围内但并不存在的数据`， InnoDB会对这个间歇加锁。比如查询`state < 100`的数据，虽然`state = 99` 并不存在，InnoDB也会对其加`间歇锁`。`间歇锁`能够避免`幻读`情况，但是会造成并发情况下的严重锁等待。

> InnoDB不会对主键或唯一索引的字段加锁，只会采用行锁。
>
> 如果需要关闭`间隙锁`，将隔离级别变为`Read Committed`即可。

