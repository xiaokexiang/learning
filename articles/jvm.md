### JVM内存区域概述

#### 虚拟机栈

虚拟机栈描述的是Java方法执行的`线程内存模型:`每个方法被执行时，JVM会同步创建一个`栈帧`，用于存储`局部变量表、操作数栈、动态链接、方法出口`等信息，虚拟机栈区域是`线程私有`的，它的生命周期与线程相同。

> 局部变量表：存放编译期可知的数据类型：`8种基本数据类型和对象引用类型`。这些数据类型在栈中用`slot`来表示，除了`long & double`占用`2个slot`，其余的都为1个。
>
> 虚拟机栈包含用于`执行native方法`的本地方法栈。它们都会抛出`OOM和StackOverFlow`异常。

---

#### 虚拟机堆

这是一块`线程共享`的内存区域，几乎全部的`对象实例、数组`都在堆上分配（小对象可以在`栈上分配`）。

> 从内存回收角度看， 堆被逻辑的分为：`年轻代（包括eden、from、to三个区域）、老年代`。
>
> 从内存分配角度看，堆被分为`多个线程私有的内存分配缓冲区（TLAB）`。

##### TLAB

Thread Local Allocation Buffer（本地线程缓冲区），原有的虚拟机给对象分配内存时，采用是`CAS + 失败重试`的方式。而`TLAB`是：

1. 通预先给每个线程在堆中分配一小块区域。
2. 哪个线程创建对象，就在哪个线程的TLAB中分配内存。
3. 如果这个线程的`TLAB`空间不够分配时，就通过`同步锁定`给这个线程分配新的`TLAB`。
4. `-XX:+/-UseTLAB`来开启和关闭TLAB。

---

### 元数据区

`JDK1.8`起，方法区改名为`元数据区（MetaSpace）`，是`线程共享`的区域，用于存储`JVM加载的类型信息、常量、静态变量`等数据。会抛出`OOM`异常。

#### 运行时常量池

运行时常量池是方法区的一部分。Class文件除了有`类的版本、字段、方法、接口`等描述信息外，还包含`常量池表（Constant Pool Table）`，用于存放编译期生成的`各中字面量和符号引用`，这部分数据会在`类加载`后被放入常量池。

> `运行时常量池`相比`常量池表`更具动态性，但并非编译期生成的Class类常量池内容才能进入方法区常量池，运行期间也可以进入，例如`String类的intern()方法`。

---

