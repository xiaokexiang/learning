### JVM内存区域概述

#### 虚拟机栈

虚拟机栈描述的是Java方法执行的`线程内存模型:`每个方法被执行时，JVM会同步创建一个`栈帧`，用于存储`局部变量表、操作数栈、动态链接、方法出口`等信息，虚拟机栈区域是`线程私有`的，它的生命周期与线程相同。

> 局部变量表：存放编译期可知的数据类型：`8种基本数据类型和对象引用类型`。这些数据类型在栈中用`slot`来表示，除了`long & double`占用`2个slot`，其余的都为1个。
>
> 虚拟机栈包含用于`执行native方法`的本地方法栈。它们都会抛出`OOM和StackOverFlow`异常。

#### 虚拟机堆

这是一块`线程共享`的内存区域，几乎全部的`对象实例、数组`都在堆上分配（小对象可以在`栈上分配`）。

> 从内存回收角度看， 堆被逻辑的分为：`年轻代（包括eden、from、to三个区域）、老年代`。
>
> 从内存分配角度看，堆被分为`多个线程私有的内存分配缓冲区（TLAB）`。

##### TLAB

Thread Local Allocation Buffer（本地线程缓冲区），原有的虚拟机给对象分配内存时，采用是`CAS + 失败重试`的方式。而`TLAB`是：

1. 通预先给每个线程在堆中分配一小块区域。
2. 哪个线程创建对象，就在哪个线程的TLAB中分配内存。
3. 如果这个线程的`TLAB`空间不够分配时，就通过`同步锁定`给这个线程分配新的`TLAB`。
4. `-XX:+/-UseTLAB`来开启和关闭TLAB。



#### 元数据区

`JDK1.8`起，方法区改名为`元数据区（MetaSpace）`，是`线程共享`的区域，用于存储`JVM加载的类型信息、常量、静态变量`等数据。会抛出`OOM`异常。

#### 运行时常量池

运行时常量池是方法区的一部分。Class文件除了有`类的版本、字段、方法、接口`等描述信息外，还包含`常量池表（Constant Pool Table）`，用于存放编译期生成的`各中字面量和符号引用`，这部分数据会在`类加载`后被放入常量池。

> `运行时常量池`相比`常量池表`更具动态性，但并非编译期生成的Class类常量池内容才能进入`方法区运行时常量池`，运行期间也可以进入，例如`String类的intern()方法`就可以实现。

---

### 程序计数器

`当前线程`所执行的字节码的行号指示器。分支、循环、异常处理都是依赖计数器实现，该区域是`线程私有`的。

### 直接内存

直接内存并不是JVM运行时数据区的一部分。常见于`NIO`类使用：通过`Native方法分配堆外内存`，在Java堆中持有该`内存区域的引用`实现操作，相比之前`在Java堆和Native堆之间来回复制`的方式，提升了效率。 

---

### 对象的创建

![](https://image.leejay.top/image/20200806/5Yyjn8VqQBwt.png?imageslim)

> 1. 在`Class类的常量池`中寻找该类的`符号引用`，并通过该符号引用判断类是否被加载。
> 2. 如果类没有被加载，那么JVM就会执行相应的类加载过程。
> 3. 给对象分配内存空间共有两种方式：`指针碰撞 & 空闲列表`。
> 4. 在对象分配内存的线程安全问题，默认是通过`CAS + 失败重试`实现，也可以选择`TLAB`。
> 5. 初始化内存空间为零值，并对`Mark Word`进行必要设置（根据是否启动偏向锁设置信息）。
> 6. 最终调用对象的构造函数进行初始化。

### 对象的构成

对象在堆中的布局分为三个部分：`对象头、实例数据和对齐填充`。而对象头中又包含：`对象自身的运行时数据(Mark Word)、对象指向它类型元数据的指针`。如果对象是数组，那么对象头还会存在记录`数组长度的数据`。

#### Mark Word

![](https://image.leejay.top/image/20200806/bf8MF7GVoqRP.png?imageslim)